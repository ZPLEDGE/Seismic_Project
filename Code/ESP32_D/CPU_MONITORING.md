# EMS Controller - CPU Load Monitoring

## Добавленная функциональность

### Мониторинг загрузки CPU

Система отслеживает и отображает приблизительную загрузку процессора для каждого ядра ESP32.

**ВАЖНО:** Из-за ограничений Arduino framework для ESP32, используется упрощенный метод расчета загрузки CPU на основе времени выполнения циклов задач. Это дает приблизительную оценку, но не абсолютно точные значения.

#### Что отслеживается:

1. **Загрузка каждого ядра (Core 0 и Core 1)** - приблизительный процент использования CPU
2. **Загрузка каждой задачи** - сколько процессорного времени использует UI_Task и Stim_Task
3. **Максимальное время выполнения цикла** - самый долгий цикл задачи (важный показатель!)
4. **Количество циклов** - сколько раз выполнилась задача

### Автоматический вывод статистики

Каждые 10 секунд (настраивается через `STATS_INTERVAL_MS`) система автоматически выводит:
- Количество циклов каждой задачи
- Количество отправленных/полученных команд
- **Максимальное время выполнения цикла** ⚠️ **Важный показатель!**
- Приблизительную загрузку CPU для каждой задачи
- Свободную память стека
- Свободную heap память
- Загрузку каждого ядра CPU

### Команды через Serial Monitor

Вы можете вручную запросить статистику, отправив команды через Serial Monitor (115200 baud):

- **`D`** или **`d`** - Детальная статистика задач
  - Показывает информацию о наших задачах
  - Ядро выполнения
  - Количество циклов
  - Приблизительную загрузку CPU
  - Свободный стек
  - Общую информацию о системе

- **`S`** или **`s`** - Системная статистика (то же, что выводится автоматически)

- **`H`**, **`h`** или **`?`** - Справка по командам

### Пример вывода

```
╔════════════════════════════════════════════╗
║          System Statistics                 ║
╠════════════════════════════════════════════╣
[UI_Task  ] Core:0 Loops:4943 Cmds:77 MaxLoop:134297 µs CPU:12.5%
[Stim_Task] Core:1 Loops:50041 Cmds:77 MaxLoop:21 µs CPU:2.1%
║ UI Stack Free: 6144 bytes                ║
║ Stim Stack Free: 5888 bytes              ║
║ Free Heap: 245632 bytes                  ║
║ Min Free Heap: 243104 bytes              ║
║ CPU Freq: 240 MHz                        ║
║                                            ║
║ Core 0 Usage: 12.5%                      ║
║ Core 1 Usage: 2.1%                       ║
║ Dual-Core: ✅ YES                         ║
╚════════════════════════════════════════════╝
```

### Расшифровка значений:

#### UI_Task:
```
[UI_Task  ] Core:0 Loops:4943 Cmds:77 MaxLoop:134297 µs CPU:12.5%
```

- **Core:0** - задача выполняется на ядре 0
- **Loops:4943** - выполнено 4943 цикла с момента запуска
- **Cmds:77** - отправлено 77 команд в очередь
- **MaxLoop:134297 µs** - максимальное время выполнения одного цикла (134 мс)
  - ⚠️ **Если больше 50 мс - это может быть проблемой!**
  - Обычно вызвано медленным Serial.printf()
- **CPU:12.5%** - задача активно использует ~12.5% времени ядра 0

#### Stim_Task:
```
[Stim_Task] Core:1 Loops:50041 Cmds:77 MaxLoop:21 µs CPU:2.1%
```

- **Core:1** - задача выполняется на ядре 1
- **Loops:50041** - выполнено 50041 цикл (больше, чем UI, т.к. задержка 1ms vs 10ms)
- **Cmds:77** - получено 77 команд из очереди
- **MaxLoop:21 µs** - максимальное время выполнения цикла (21 микросекунда)
  - ✅ **Отлично! Быстрое выполнение**
- **CPU:2.1%** - задача активно использует ~2.1% времени ядра 1

### Технические детали

#### Метод расчета загрузки CPU

Из-за ограничений Arduino framework для ESP32, стандартные функции FreeRTOS для статистики (`uxTaskGetSystemState`, `vTaskGetRunTimeStats`) недоступны.

Используется упрощенный метод:

```cpp
// Активное время = количество циклов × максимальное время цикла
activeTime = loopCount × maxLoopTime

// Загрузка CPU = (активное время / общее время) × 100%
cpuUsage = (activeTime / totalTime) × 100%
```

**Ограничения:**
- Это приблизительная оценка, не абсолютно точная
- Использует `maxLoopTime` как оценку среднего времени
- Не учитывает другие системные задачи (WiFi, Bluetooth и т.д.)

#### Более точные значения

Для получения более точных значений загрузки CPU нужно:
1. Использовать ESP-IDF framework вместо Arduino
2. Включить `CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS` в sdkconfig
3. Использовать `uxTaskGetSystemState()` для получения точной статистики

### Анализ производительности

#### ⚠️ Проблемные показатели:

1. **MaxLoop > 50 мс** для UI_Task
   - Обычно вызвано медленным Serial.printf()
   - Решение: уменьшить количество выводов или использовать буферизацию

2. **MaxLoop > 1 мс** для Stim_Task
   - Может привести к пропуску импульсов стимуляции
   - Решение: оптимизировать код генерации импульсов

3. **CPU > 80%** для любой задачи
   - Система перегружена
   - Решение: увеличить задержки или оптимизировать код

#### ✅ Хорошие показатели:

1. **MaxLoop < 10 мс** для UI_Task
2. **MaxLoop < 100 µs** для Stim_Task
3. **CPU < 50%** для обеих задач
4. **Задачи на разных ядрах** (Dual-Core: ✅ YES)

### Оптимизация производительности

#### 1. Уменьшить вывод в Serial

Serial.printf() блокирует выполнение и может занимать много времени.

```cpp
// Плохо: вывод при каждом изменении
encoderA.onStep([](int8_t delta) {
    Serial.printf("Changed: %d\n", delta);  // Медленно!
});

// Хорошо: вывод только при необходимости
encoderA.onStep([](int8_t delta) {
    // Обновляем параметры без вывода
    appState.adjustCurrentParam(delta);
});
```

#### 2. Увеличить интервал статистики

```cpp
// В main.cpp
constexpr uint32_t STATS_INTERVAL_MS = 30000; // 30 секунд вместо 10
```

#### 3. Оптимизировать критичные участки

Для Stim_Task важно минимизировать время выполнения:
```cpp
// Избегайте в Stim_Task:
- Serial.printf()
- Сложных вычислений
- Блокирующих операций
```

### Рекомендации по использованию

1. **Мониторьте MaxLoop** - это самый важный показатель
2. **Следите за стеком** - если меньше 512 байт, увеличьте размер
3. **Проверяйте Dual-Core** - задачи должны быть на разных ядрах
4. **CPU Usage** - используйте как ориентир, не как абсолютное значение

### Известные ограничения

1. **Приблизительный расчет CPU** - не абсолютно точный
2. **Не учитывает системные задачи** - WiFi, Bluetooth, и т.д.
3. **MaxLoop может быть завышен** - из-за редких пиков (например, вывод статистики)
4. **Первые значения могут быть неточными** - нужно время для стабилизации

### Для разработчиков

Если нужны более точные значения, рассмотрите:
1. Переход на ESP-IDF framework
2. Использование профилировщика ESP32
3. Добавление собственных счетчиков времени с `esp_timer_get_time()`
